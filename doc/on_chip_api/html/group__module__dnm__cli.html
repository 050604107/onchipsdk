<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>SmartMesh IP On-Chip API: CLI module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logos.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartMesh IP On-Chip API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Components</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__module__dnm__cli.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">CLI module<div class="ingroups"><a class="el" href="group___services.html">Services</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Application-level module to build a command line interface.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Application-level module to build a command line interface. </p>
<h1><a class="anchor" id="sec_dbm_cli_overview"></a>
Overview</h1>
<p>This module provides simple functions to build a command line interface. Internally, it drives the <a class="el" href="group__device__cli.html">CLI</a> device. While your application can choose to interact with the <a class="el" href="group__device__cli.html">CLI</a> device directly, we recommend using this wrapper module for simplicity.</p>
<h1><a class="anchor" id="sec_dbm_cli_general"></a>
General Use</h1>
<p>To use the <a class="el" href="group__module__dnm__cli.html">CLI module</a>, your application has to:</p>
<ul>
<li>Create an asynchronous channel to receive notifications from the <a class="el" href="group__device__cli.html">CLI</a> device. We recommend to create the channel with a memory pool that contains at least one buffer of size <a class="el" href="group__dn__channel.html#gade6e9dca8029fda9015551f2fbd8707e" title="The pool size for receiving async messages should have space for a dn_chan_msg_hdr_t structure...">DN_CH_ASYNC_RXBUF_SIZE</a>(<a class="el" href="group__device__cli.html#ga3c46007456f04011b0e65b7d75059b60" title="Maximum number of bytes in a CLI notification message.">DN_CLI_NOTIF_SIZE</a>)</li>
<li>Create one or more handler functions for each of the commands that you want to terminate on the CLI. A handler function is invoked with the full input string whenever the first word of the input string matches the command.</li>
<li>Declare the CLI context via a variable of type <a class="el" href="structdnm__cli__cont__t.html" title="Application&#39;s CLI context.">dnm_cli_cont_t</a>. Call <a class="el" href="group__module__dnm__cli.html#ga91c81423026ea0b2d5ac63318aa15eb9" title="Initialize the CLI context.">dnm_cli_initContext()</a> to initialize the CLI context, which allows you to define a list of CLI commands and their associated handler functions.</li>
<li>Call <a class="el" href="group__module__dnm__cli.html#gac307d152ace923149e855a2a5a70ca01" title="Wrapper to open the CLI serial port.">dnm_cli_openPort()</a> or <a class="el" href="group__module__dnm__cli.html#gac76f94a2380fe5fbce9c1d03c6c1f3b4" title="Open the CLI serial port using information stored in flash memory.">dnm_cli_open()</a> to open the CLI port.</li>
<li>Continuously call the (blocking) function <a class="el" href="group__module__dnm__cli.html#ga1949feb6ce7afd4d203eaca05b48d8b9" title="Wait for CLI input and process it.">dnm_cli_input()</a> from a task to wait for and process user CLI input. This function will in turn invoke the appropriate handlers provided by your application. Alternatively, your application can read messages from the <a class="el" href="group__device__cli.html">CLI</a> device's channel directly and call <a class="el" href="group__module__dnm__cli.html#gac94e50d58821e125722b949938119128" title="Process some CLI input.">dnm_cli_procNotif()</a>.</li>
<li>Use <a class="el" href="group__module__dnm__cli.html#gaa4cd980822e9c729652a5ae35e6df16e" title="Print a formatted string.">dnm_cli_printf()</a> to output text to the CLI serial port at any time (including from within command handlers)</li>
</ul>
<h1><a class="anchor" id="sec_dbm_cli_tracing"></a>
Tracing</h1>
<p>The <a class="el" href="group__module__dnm__cli.html">CLI module</a> module has support for simple tracing. Your application can use <a class="el" href="group__module__dnm__cli.html#ga297f74f0bd85eea3265379f5c4fd4f9b" title="Print a formatted trace string if the corresponding trace flag is enabled.">dnm_cli_trace()</a> and <a class="el" href="group__module__dnm__cli.html#ga98e338a7adb6d30008daa93e429e8fb3" title="Print binary data if the corresponding trace flag is enabled.">dnm_cli_traceDump()</a> functions to conditionally output text to the CLI port. Text of the trace will only be printed if the corresponding trace flag is enabled inside the CLI context (see <a class="el" href="group__module__dnm__cli.html#ga9fb8bb13ddd7d6728e7c18d541c0dc9c" title="Set/clear some trace flag.">dnm_cli_setTrace()</a>).</p>
<p>Optionally, your application can support user-enabled control of traces with a "&lt;tt&gt;trace XX &lt;on|off&gt;&lt;/tt&gt;" cli command. The handler for such trace command can use <a class="el" href="group__module__dnm__cli.html#gab8c9b893c7621b4db5597cb4842bb166" title="Parse command string to set/clear some trace flag.">dnm_cli_setTraceByName()</a> function to parse the command and control trace flags. To use <a class="el" href="group__module__dnm__cli.html#gab8c9b893c7621b4db5597cb4842bb166" title="Parse command string to set/clear some trace flag.">dnm_cli_setTraceByName()</a>, you need to have an array of <a class="el" href="structdnm__cli__trinfo__t.html" title="Trace module descriptor.">dnm_cli_trinfo_t</a> descriptors corresponding to the trace flags. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnm__cli__cmd_def__t.html">dnm_cli_cmdDef_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLI command descriptor.  <a href="structdnm__cli__cmd_def__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application's CLI context.  <a href="structdnm__cli__cont__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace module descriptor.  <a href="structdnm__cli__trinfo__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Defines</h2></td></tr>
<tr class="memitem:gaffa2c3ad646ea14cf1a034c341caf19c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gaffa2c3ad646ea14cf1a034c341caf19c">DEFAULT_BAUDRATE</a></td></tr>
<tr class="memdesc:gaffa2c3ad646ea14cf1a034c341caf19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baudrate for the CLI serial port.  <a href="#gaffa2c3ad646ea14cf1a034c341caf19c">More...</a><br/></td></tr>
<tr class="separator:gaffa2c3ad646ea14cf1a034c341caf19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2d01910aa1fb837f2f0ec024b528e857"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga2d01910aa1fb837f2f0ec024b528e857">dnm_cli_cmdHandler_t</a> )(INT8U *cmd, INT32U len, INT8U access)</td></tr>
<tr class="memdesc:ga2d01910aa1fb837f2f0ec024b528e857"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined CLI command handler.  <a href="#ga2d01910aa1fb837f2f0ec024b528e857">More...</a><br/></td></tr>
<tr class="separator:ga2d01910aa1fb837f2f0ec024b528e857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eebe8166021775a92ef50986538b565"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga0eebe8166021775a92ef50986538b565">dnm_cli_helpHandler_t</a> )(const <a class="el" href="structdnm__cli__cmd_def__t.html">dnm_cli_cmdDef_t</a> *pCmdDef)</td></tr>
<tr class="memdesc:ga0eebe8166021775a92ef50986538b565"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined CLI help handler.  <a href="#ga0eebe8166021775a92ef50986538b565">More...</a><br/></td></tr>
<tr class="separator:ga0eebe8166021775a92ef50986538b565"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CLI module API</h2></td></tr>
<tr class="memitem:gac307d152ace923149e855a2a5a70ca01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gac307d152ace923149e855a2a5a70ca01">dnm_cli_openPort</a> (INT8U port, INT32U baudRate)</td></tr>
<tr class="memdesc:gac307d152ace923149e855a2a5a70ca01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to open the CLI serial port.  <a href="#gac307d152ace923149e855a2a5a70ca01">More...</a><br/></td></tr>
<tr class="separator:gac307d152ace923149e855a2a5a70ca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76f94a2380fe5fbce9c1d03c6c1f3b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gac76f94a2380fe5fbce9c1d03c6c1f3b4">dnm_cli_open</a> (INT32U baudRate)</td></tr>
<tr class="memdesc:gac76f94a2380fe5fbce9c1d03c6c1f3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the CLI serial port using information stored in flash memory.  <a href="#gac76f94a2380fe5fbce9c1d03c6c1f3b4">More...</a><br/></td></tr>
<tr class="separator:gac76f94a2380fe5fbce9c1d03c6c1f3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91c81423026ea0b2d5ac63318aa15eb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga91c81423026ea0b2d5ac63318aa15eb9">dnm_cli_initContext</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *context, <a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> inpCh, const <a class="el" href="structdnm__cli__cmd_def__t.html">dnm_cli_cmdDef_t</a> *cmdArr)</td></tr>
<tr class="memdesc:ga91c81423026ea0b2d5ac63318aa15eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the CLI context.  <a href="#ga91c81423026ea0b2d5ac63318aa15eb9">More...</a><br/></td></tr>
<tr class="separator:ga91c81423026ea0b2d5ac63318aa15eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce46154c9df774d3beaf33ca999cf65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga4ce46154c9df774d3beaf33ca999cf65">dnm_cli_setHelpHandler</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, <a class="el" href="group__module__dnm__cli.html#ga0eebe8166021775a92ef50986538b565">dnm_cli_helpHandler_t</a> pfHelpHandler)</td></tr>
<tr class="memdesc:ga4ce46154c9df774d3beaf33ca999cf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a custom help handler.  <a href="#ga4ce46154c9df774d3beaf33ca999cf65">More...</a><br/></td></tr>
<tr class="separator:ga4ce46154c9df774d3beaf33ca999cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11a71905671ec32dbcc249afd60483f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gaa11a71905671ec32dbcc249afd60483f">dnm_cli_changeAccessLevel</a> (<a class="el" href="group__device__cli.html#ga564d7eaa67afa6d784f3d3c75da80869">dn_cli_access_t</a> newAccessLevel)</td></tr>
<tr class="memdesc:gaa11a71905671ec32dbcc249afd60483f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current user access level.  <a href="#gaa11a71905671ec32dbcc249afd60483f">More...</a><br/></td></tr>
<tr class="separator:gaa11a71905671ec32dbcc249afd60483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4cd980822e9c729652a5ae35e6df16e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gaa4cd980822e9c729652a5ae35e6df16e">dnm_cli_printf</a> (const char *format,...)</td></tr>
<tr class="memdesc:gaa4cd980822e9c729652a5ae35e6df16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a formatted string.  <a href="#gaa4cd980822e9c729652a5ae35e6df16e">More...</a><br/></td></tr>
<tr class="separator:gaa4cd980822e9c729652a5ae35e6df16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1949feb6ce7afd4d203eaca05b48d8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga1949feb6ce7afd4d203eaca05b48d8b9">dnm_cli_input</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pContext)</td></tr>
<tr class="memdesc:ga1949feb6ce7afd4d203eaca05b48d8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for CLI input and process it.  <a href="#ga1949feb6ce7afd4d203eaca05b48d8b9">More...</a><br/></td></tr>
<tr class="separator:ga1949feb6ce7afd4d203eaca05b48d8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac94e50d58821e125722b949938119128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gac94e50d58821e125722b949938119128">dnm_cli_procNotif</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, INT32S msgType, <a class="el" href="structdn__cli__notif_msg__t.html">dn_cli_notifMsg_t</a> *pCliNotif, INT32S rxLen)</td></tr>
<tr class="memdesc:gac94e50d58821e125722b949938119128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process some CLI input.  <a href="#gac94e50d58821e125722b949938119128">More...</a><br/></td></tr>
<tr class="separator:gac94e50d58821e125722b949938119128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac558df494bff5224e445182e45e1ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga0ac558df494bff5224e445182e45e1ec">dnm_cli_usage</a> (const <a class="el" href="structdnm__cli__cmd_def__t.html">dnm_cli_cmdDef_t</a> *pCmdDef)</td></tr>
<tr class="memdesc:ga0ac558df494bff5224e445182e45e1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a CLI command usage string.  <a href="#ga0ac558df494bff5224e445182e45e1ec">More...</a><br/></td></tr>
<tr class="separator:ga0ac558df494bff5224e445182e45e1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14aad51e35102b5d90827d563e82fec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga14aad51e35102b5d90827d563e82fec3">dnm_cli_setOutputMode</a> (BOOLEAN fBlocking)</td></tr>
<tr class="memdesc:ga14aad51e35102b5d90827d563e82fec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch between blocking and non-blocking output modes.  <a href="#ga14aad51e35102b5d90827d563e82fec3">More...</a><br/></td></tr>
<tr class="separator:ga14aad51e35102b5d90827d563e82fec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad338139361a66c88486b810a617f897e"><td class="memItemLeft" align="right" valign="top">INT8U&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gad338139361a66c88486b810a617f897e">dnm_cli_getPort</a> (void)</td></tr>
<tr class="memdesc:gad338139361a66c88486b810a617f897e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the CLI port.  <a href="#gad338139361a66c88486b810a617f897e">More...</a><br/></td></tr>
<tr class="separator:gad338139361a66c88486b810a617f897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843d3052d27f45c1bc20d1229992ffe1"><td class="memItemLeft" align="right" valign="top">INT32U&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga843d3052d27f45c1bc20d1229992ffe1">dnm_cli_getBaudRate</a> (void)</td></tr>
<tr class="memdesc:ga843d3052d27f45c1bc20d1229992ffe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the CLI baudrate.  <a href="#ga843d3052d27f45c1bc20d1229992ffe1">More...</a><br/></td></tr>
<tr class="separator:ga843d3052d27f45c1bc20d1229992ffe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Print formatting</h2></td></tr>
<tr class="memitem:gaff4fde9871032cd31b7d96a8fbb2e7cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gaff4fde9871032cd31b7d96a8fbb2e7cf">dnm_cli_printfTimestamp</a> (const char *format,...)</td></tr>
<tr class="memdesc:gaff4fde9871032cd31b7d96a8fbb2e7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a timestamp, followed by a formatted string.  <a href="#gaff4fde9871032cd31b7d96a8fbb2e7cf">More...</a><br/></td></tr>
<tr class="separator:gaff4fde9871032cd31b7d96a8fbb2e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5229d2081d194c7496b6bac1c59153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga4c5229d2081d194c7496b6bac1c59153">dnm_cli_dump</a> (const INT8U *data, INT32S len, const char *format,...)</td></tr>
<tr class="memdesc:ga4c5229d2081d194c7496b6bac1c59153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some binary data.  <a href="#ga4c5229d2081d194c7496b6bac1c59153">More...</a><br/></td></tr>
<tr class="separator:ga4c5229d2081d194c7496b6bac1c59153"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tracing</h2></td></tr>
<tr class="memitem:ga297f74f0bd85eea3265379f5c4fd4f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga297f74f0bd85eea3265379f5c4fd4f9b">dnm_cli_trace</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, INT32S traceFlag, const char *format,...)</td></tr>
<tr class="memdesc:ga297f74f0bd85eea3265379f5c4fd4f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a formatted trace string if the corresponding trace flag is enabled.  <a href="#ga297f74f0bd85eea3265379f5c4fd4f9b">More...</a><br/></td></tr>
<tr class="separator:ga297f74f0bd85eea3265379f5c4fd4f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e338a7adb6d30008daa93e429e8fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga98e338a7adb6d30008daa93e429e8fb3">dnm_cli_traceDump</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, INT32S traceFlag, const INT8U *data, INT32S len, const char *format,...)</td></tr>
<tr class="memdesc:ga98e338a7adb6d30008daa93e429e8fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print binary data if the corresponding trace flag is enabled.  <a href="#ga98e338a7adb6d30008daa93e429e8fb3">More...</a><br/></td></tr>
<tr class="separator:ga98e338a7adb6d30008daa93e429e8fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af8287095ce6ccdbfd8d86ea2774f85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga4af8287095ce6ccdbfd8d86ea2774f85">dnm_cli_traceDumpBlocking</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, INT32S traceFlag, const INT8U *data, INT32S len, const char *format,...)</td></tr>
<tr class="memdesc:ga4af8287095ce6ccdbfd8d86ea2774f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as dnm_cli_traceDump with a Mutex to prevent overlapping prints.  <a href="#ga4af8287095ce6ccdbfd8d86ea2774f85">More...</a><br/></td></tr>
<tr class="separator:ga4af8287095ce6ccdbfd8d86ea2774f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2abd18abfc5b308d0a473d82e745e3"><td class="memItemLeft" align="right" valign="top">BOOLEAN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga9e2abd18abfc5b308d0a473d82e745e3">dnm_cli_isTraceOn</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, INT32S traceFlag)</td></tr>
<tr class="memdesc:ga9e2abd18abfc5b308d0a473d82e745e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether some trace flag is enabled.  <a href="#ga9e2abd18abfc5b308d0a473d82e745e3">More...</a><br/></td></tr>
<tr class="separator:ga9e2abd18abfc5b308d0a473d82e745e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb8bb13ddd7d6728e7c18d541c0dc9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga9fb8bb13ddd7d6728e7c18d541c0dc9c">dnm_cli_setTrace</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, INT32S traceFlag, BOOLEAN value)</td></tr>
<tr class="memdesc:ga9fb8bb13ddd7d6728e7c18d541c0dc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/clear some trace flag.  <a href="#ga9fb8bb13ddd7d6728e7c18d541c0dc9c">More...</a><br/></td></tr>
<tr class="separator:ga9fb8bb13ddd7d6728e7c18d541c0dc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c9b893c7621b4db5597cb4842bb166"><td class="memItemLeft" align="right" valign="top">BOOLEAN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gab8c9b893c7621b4db5597cb4842bb166">dnm_cli_setTraceByName</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *trInfo, char **arg)</td></tr>
<tr class="memdesc:gab8c9b893c7621b4db5597cb4842bb166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command string to set/clear some trace flag.  <a href="#gab8c9b893c7621b4db5597cb4842bb166">More...</a><br/></td></tr>
<tr class="separator:gab8c9b893c7621b4db5597cb4842bb166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f57c81711d0dac0f14edfd1dbabaf6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga9f57c81711d0dac0f14edfd1dbabaf6c">dnm_cli_printTraceStateByName</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *trInfo)</td></tr>
<tr class="memdesc:ga9f57c81711d0dac0f14edfd1dbabaf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the state of all trace flags.  <a href="#ga9f57c81711d0dac0f14edfd1dbabaf6c">More...</a><br/></td></tr>
<tr class="separator:ga9f57c81711d0dac0f14edfd1dbabaf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddb182397491f5d665bd8c28e2d1ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga1ddb182397491f5d665bd8c28e2d1ab6">dnm_cli_helpTrace</a> (const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *trInfo)</td></tr>
<tr class="memdesc:ga1ddb182397491f5d665bd8c28e2d1ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of all trace modules.  <a href="#ga1ddb182397491f5d665bd8c28e2d1ab6">More...</a><br/></td></tr>
<tr class="separator:ga1ddb182397491f5d665bd8c28e2d1ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e28c4434607fb47714aff262453a983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga5e28c4434607fb47714aff262453a983">dnm_cli_showTrace</a> (<a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *pCont, const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *trInfo)</td></tr>
<tr class="memdesc:ga5e28c4434607fb47714aff262453a983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of enabled trace modules.  <a href="#ga5e28c4434607fb47714aff262453a983">More...</a><br/></td></tr>
<tr class="separator:ga5e28c4434607fb47714aff262453a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Miscellaneous Utility Functions</h2></td></tr>
<tr class="memitem:gab1ee97e9befcad6d2488ffd29ca39697"><td class="memItemLeft" align="right" valign="top">BOOLEAN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gab1ee97e9befcad6d2488ffd29ca39697">dnm_cli_isNextToken</a> (char *buf, const char *keyWord, INT8U delimiter)</td></tr>
<tr class="memdesc:gab1ee97e9befcad6d2488ffd29ca39697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the next token in some with a given keyword.  <a href="#gab1ee97e9befcad6d2488ffd29ca39697">More...</a><br/></td></tr>
<tr class="separator:gab1ee97e9befcad6d2488ffd29ca39697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a558f2f3741279a6c0ccbef08354da"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga34a558f2f3741279a6c0ccbef08354da">dnm_cli_getNextToken</a> (char **p, INT8U delimiter)</td></tr>
<tr class="memdesc:ga34a558f2f3741279a6c0ccbef08354da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the next token in a string.  <a href="#ga34a558f2f3741279a6c0ccbef08354da">More...</a><br/></td></tr>
<tr class="separator:ga34a558f2f3741279a6c0ccbef08354da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ad1169f3848399aeeb810a0b6d5ed6"><td class="memItemLeft" align="right" valign="top">BOOLEAN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#gaf4ad1169f3848399aeeb810a0b6d5ed6">dnm_cli_isEquIgnoreCase</a> (const char *s1, const char *s2)</td></tr>
<tr class="memdesc:gaf4ad1169f3848399aeeb810a0b6d5ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, but ignore case.  <a href="#gaf4ad1169f3848399aeeb810a0b6d5ed6">More...</a><br/></td></tr>
<tr class="separator:gaf4ad1169f3848399aeeb810a0b6d5ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a48d00aff005ad8c1e48e7a0b761f6c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__dnm__cli.html#ga0a48d00aff005ad8c1e48e7a0b761f6c">dnm_cli_uint64ToString</a> (INT64U asn, char *buf, int size)</td></tr>
<tr class="memdesc:ga0a48d00aff005ad8c1e48e7a0b761f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a INT64 number to a string.  <a href="#ga0a48d00aff005ad8c1e48e7a0b761f6c">More...</a><br/></td></tr>
<tr class="separator:ga0a48d00aff005ad8c1e48e7a0b761f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Defines</h2>
<a class="anchor" id="gaffa2c3ad646ea14cf1a034c341caf19c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_BAUDRATE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Baudrate for the CLI serial port. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2d01910aa1fb837f2f0ec024b528e857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>(* dnm_cli_cmdHandler_t)(INT8U *cmd, INT32U len, INT8U access)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined CLI command handler. </p>
<p>Typically, thius function parses parameters and handles the command accordingly.</p>
<p>The CLI module invokes this function via the command descriptors in <a class="el" href="structdnm__cli__cont__t.html" title="Application&#39;s CLI context.">dnm_cli_cont_t</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error.">DN_ERR_NONE</a> when the function terminates successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a6ced3cd8aceb155b107c43d87586927a" title="(-1) Common error code.">DN_ERR_ERROR</a> when the function can not terminate successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter.">DN_ERR_INVALID</a> when the user entered an invalid parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eebe8166021775a92ef50986538b565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* dnm_cli_helpHandler_t)(const <a class="el" href="structdnm__cli__cmd_def__t.html">dnm_cli_cmdDef_t</a> *pCmdDef)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined CLI help handler. </p>
<p>The library has a default handler that prints the usage string passed in the <a class="el" href="structdnm__cli__cmd_def__t.html#aef1bd6ad890a110b466cb0e8088507a2" title="Brief usage string.">dnm_cli_cmdDef_t::usage</a> elements when registering the commands. This is invoked when the user enters "help" followed by the command of interest.</p>
<p>Alternatively, you can define a custom function to handle help for all application commands. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac307d152ace923149e855a2a5a70ca01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dnm_cli_openPort </td>
          <td>(</td>
          <td class="paramtype">INT8U&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>baudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to open the CLI serial port. </p>
<dl class="section pre"><dt>Precondition</dt><dd>You need to call this function exactly once before you can use the CLI. </dd>
<dd>
This function is invoked by <a class="el" href="group__module__dnm__cli.html#gac76f94a2380fe5fbce9c1d03c6c1f3b4" title="Open the CLI serial port using information stored in flash memory.">dnm_cli_open()</a> if you choose to use it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The CLI port to open. Acceptable values are listed in <a class="el" href="group__device__cli.html#ga24b1e875c82db7f840e73c361b8a34c4" title="Available CLI ports.">dn_cli_port_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baudRate</td><td>The CLI's baudrate. Use <a class="el" href="group__module__dnm__cli.html#gaffa2c3ad646ea14cf1a034c341caf19c" title="Baudrate for the CLI serial port.">DEFAULT_BAUDRATE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same error are the ones returns by the <a class="el" href="group__device__api.html#ga561ddfae94783e45d60c75d1493efa2e" title="Open a device.">dn_open()</a> function for the <a class="el" href="group__device__cli.html">CLI</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac76f94a2380fe5fbce9c1d03c6c1f3b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dnm_cli_open </td>
          <td>(</td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>baudRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the CLI serial port using information stored in flash memory. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This function calls <a class="el" href="group__module__dnm__cli.html#gac307d152ace923149e855a2a5a70ca01" title="Wrapper to open the CLI serial port.">dnm_cli_openPort</a></dd></dl>
<p>This function reads the CLI port info from the <a class="el" href="group__device__flashinfo.html">flashinfo</a>. Baudrate is only read from <a class="el" href="group__device__flashinfo.html">flashinfo</a> if the <code>baudRate</code> parameter is set to <code>0</code>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baudRate</td><td>The CLI's baudrate. Use <a class="el" href="group__module__dnm__cli.html#gaffa2c3ad646ea14cf1a034c341caf19c" title="Baudrate for the CLI serial port.">DEFAULT_BAUDRATE</a> or set to <code>0</code> to use the one from <a class="el" href="group__device__flashinfo.html">flashinfo</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a6ced3cd8aceb155b107c43d87586927a" title="(-1) Common error code.">DN_ERR_ERROR</a> if the CLI port information could not be read from the <a class="el" href="group__device__flashinfo.html">flashinfo</a>. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter.">DN_ERR_INVALID</a> if the information retrieved from the <a class="el" href="group__device__flashinfo.html">flashinfo</a> indicates CLI is not enabled. </dd>
<dd>
The same error are the ones returns by the <a class="el" href="group__module__dnm__cli.html#gac307d152ace923149e855a2a5a70ca01" title="Wrapper to open the CLI serial port.">dnm_cli_openPort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91c81423026ea0b2d5ac63318aa15eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dnm_cli_initContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>inpCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnm__cli__cmd_def__t.html">dnm_cli_cmdDef_t</a> *&#160;</td>
          <td class="paramname"><em>cmdArr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the CLI context. </p>
<p>The CLI context is defined in the <a class="el" href="structdnm__cli__cont__t.html" title="Application&#39;s CLI context.">dnm_cli_cont_t</a> structure. This function initializes a pre-allocated variable of that type. Every context needs a unique channel.</p>
<dl class="section note"><dt>Note</dt><dd>Call this function after the OS has started.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The last <code>cmdArr</code> entry must contain a <code>NULL</code> command pointer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCont</td><td>Pointer to a pre-allocated CLI context. This function will clear the information contained in that variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpCh</td><td>Channel for receiving CLI input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdArr</td><td>Array of commands to register with the <a class="el" href="group__device__cli.html">CLI</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error.">DN_ERR_NONE</a> if the initialization is successful. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a6ced3cd8aceb155b107c43d87586927a" title="(-1) Common error code.">DN_ERR_ERROR</a> if a command length specified in the command array is longer than <a class="el" href="group__device__cli.html#ga6cb231c20325d22f184b075051136c08" title="Maximum number of bytes in a CLI control message.">DN_CLI_CTRL_SIZE</a>. </dd>
<dd>
The error received from calling <a class="el" href="group__device__api.html#ga01150f35c57e36417fd1e584bcca1e6f" title="Control a previously opened device.">dn_ioctl()</a> in the <a class="el" href="group__device__cli.html">CLI</a>, if that call fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ce46154c9df774d3beaf33ca999cf65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_setHelpHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__module__dnm__cli.html#ga0eebe8166021775a92ef50986538b565">dnm_cli_helpHandler_t</a>&#160;</td>
          <td class="paramname"><em>pfHelpHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a custom help handler. </p>
<p>Allows your application to register a function that will be called when help is invoked for one of the commands. If you do not register your custon handler (i.e. if your application does not call this function), the usage string associated with the command will be displayed by default.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This function modifies the CLI context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCont</td><td>The CLI context to modify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfHelpHandler</td><td>Pointer to the help handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa11a71905671ec32dbcc249afd60483f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dnm_cli_changeAccessLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device__cli.html#ga564d7eaa67afa6d784f3d3c75da80869">dn_cli_access_t</a>&#160;</td>
          <td class="paramname"><em>newAccessLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current user access level. </p>
<p>Sets new current user access level. Each command is associated a minimum access level for each command (<a class="el" href="structdn__cli__register_cmd_hdr__t.html#a04599b857463522758825102fdd33ce7" title="Access level of the CLI command.">dn_cli_registerCmdHdr_t::accessLevel</a>). Raising the user access level gives the user access to more commands.</p>
<p>It's your application's responsibility to raise/lower the user access level appropriately. For example, you could implement a 'login' and 'logout' CLI command to raise/lower the access level (a parameter for the 'login' CLI command could be a password).</p>
<dl class="section post"><dt>Postcondition</dt><dd>After this function returns, the user may have access to more/less CLI commands, depending on the user access level set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newAccessLevel</td><td>New user access level. Acceptable values are listed in dn_cli_access_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error received from calling <a class="el" href="group__device__api.html#ga01150f35c57e36417fd1e584bcca1e6f" title="Control a previously opened device.">dn_ioctl()</a> in the <a class="el" href="group__device__cli.html">CLI</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4cd980822e9c729652a5ae35e6df16e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a formatted string. </p>
<p>Call this function to print a string with printf-like formatting. For example, call</p>
<p><code>dnm_cli_printf("v=%d", v);</code></p>
<p>to print the value of variable <code>v</code> as a decimal number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Sprintf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">'...'</td><td>Optional format arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1949feb6ce7afd4d203eaca05b48d8b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dnm_cli_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for CLI input and process it. </p>
<p>This function blocks waiting for CLI input. When it receives input, it invokes the appropriate CLI command handler. If the CLI command handler returns an error, the help handler is invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error.">DN_ERR_NONE</a> if CLI input was received and handled correctly. </dd>
<dd>
A error if the CLI channel could not be read (see <a class="el" href="group__dn__channel.html#ga5c9c22db91662dafbb18a04bda9bf459" title="Read a message from an asynchronous channel.">dn_readAsyncMsg()</a>). </dd>
<dd>
A error if CLI command could not be processed (see <a class="el" href="group__module__dnm__cli.html#gac94e50d58821e125722b949938119128" title="Process some CLI input.">dnm_cli_procNotif()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="gac94e50d58821e125722b949938119128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dnm_cli_procNotif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdn__cli__notif_msg__t.html">dn_cli_notifMsg_t</a> *&#160;</td>
          <td class="paramname"><em>pCliNotif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>rxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process some CLI input. </p>
<p>Your application can call this function with input received from the CLI channel. It invokes the appropriate CLI command handler, or the help handler if the CLI command handler returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message received over the CLI channel. This function expects this to be set to <a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a79d26c33025650ff054b1fd8d0f710a1" title="CLI notification.">DN_MSG_TYPE_CLI_NOTIF</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCliNotif</td><td>Notification received on the CLI channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxLen</td><td>Length of the notification received on the CLI channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error.">DN_ERR_NONE</a> if CLI input was handled correctly. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a5318a9f45ed5ad2e5edbf25f953633b6" title="(-14) Read error.">DN_ERR_READ</a> if the notification type is not DN_MSG_TYPE_CLI_NOTIF, or if <code>rxLen</code> is <code>0</code>. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a863afaf6ed9306c2802ac1497ffb7469" title="(-17) Request is valid but not supported.">DN_ERR_NOT_SUPPORTED</a> if the comand ID is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ac558df494bff5224e445182e45e1ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_usage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnm__cli__cmd_def__t.html">dnm_cli_cmdDef_t</a> *&#160;</td>
          <td class="paramname"><em>pCmdDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a CLI command usage string. </p>
<p>When defining a CLI command, <a class="el" href="structdnm__cli__cmd_def__t.html#aef1bd6ad890a110b466cb0e8088507a2" title="Brief usage string.">dnm_cli_cmdDef_t::usage</a> allows your application to associate a usage string, i.e. some text explaining how to use this CLI command.</p>
<p>Call this function to print this usage string over the CLI serial port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCmdDef</td><td>Descriptor of a command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga14aad51e35102b5d90827d563e82fec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_setOutputMode </td>
          <td>(</td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>fBlocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch between blocking and non-blocking output modes. </p>
<p>The CLI device supports blocking and non-blocking output modes:</p>
<ul>
<li>in blocking mode, a call to <a class="el" href="group__device__api.html#gaaafdc1ad147827ec641bd7b9dd2e762d" title="Write to a previously opened device.">dn_write()</a> blocks until the bytes are written in the CLI output buffer and are scheduled to be printed over the serial port.</li>
<li>in non-blocking mode, a call to <a class="el" href="group__device__api.html#gaaafdc1ad147827ec641bd7b9dd2e762d" title="Write to a previously opened device.">dn_write()</a> returns immediately, even when the serial transmit buffer is full. In this case, the bytes are dropped and not printed over the serial port; the characters <code>...</code> print over the serial port to indicate to the user some characters were dropped.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fBlocking</td><td>Set to <code>TRUE</code> to swicth to blocking mode; set to <code>FALSE</code> to swicth to non-blocking mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad338139361a66c88486b810a617f897e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT8U dnm_cli_getPort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the CLI port. </p>
<dl class="section return"><dt>Returns</dt><dd>The CLI serial port, one of the elements in <a class="el" href="group__device__cli.html#ga24b1e875c82db7f840e73c361b8a34c4" title="Available CLI ports.">dn_cli_port_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga843d3052d27f45c1bc20d1229992ffe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32U dnm_cli_getBaudRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the CLI baudrate. </p>
<dl class="section return"><dt>Returns</dt><dd>The CLI serial baudrate. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff4fde9871032cd31b7d96a8fbb2e7cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_printfTimestamp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a timestamp, followed by a formatted string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Sprintf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Optional format arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c5229d2081d194c7496b6bac1c59153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_dump </td>
          <td>(</td>
          <td class="paramtype">const INT8U *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print some binary data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the start of the data to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Sprintf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Optional format arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga297f74f0bd85eea3265379f5c4fd4f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>traceFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a formatted trace string if the corresponding trace flag is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">traceFlag</td><td>Trace module mask corresponding to this trace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Sprintf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Optional format arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98e338a7adb6d30008daa93e429e8fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_traceDump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>traceFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const INT8U *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print binary data if the corresponding trace flag is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">traceFlag</td><td>Trace module mask corresponding to this trace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the start of the data to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Sprintf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Optional format arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4af8287095ce6ccdbfd8d86ea2774f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_traceDumpBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>traceFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const INT8U *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as dnm_cli_traceDump with a Mutex to prevent overlapping prints. </p>

</div>
</div>
<a class="anchor" id="ga9e2abd18abfc5b308d0a473d82e745e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN dnm_cli_isTraceOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>traceFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether some trace flag is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">traceFlag</td><td>Some trace flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> if the trace flag is enabled. </dd>
<dd>
<code>FALSE</code> if the trace flag is not enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fb8bb13ddd7d6728e7c18d541c0dc9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_setTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32S&#160;</td>
          <td class="paramname"><em>traceFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/clear some trace flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">traceFlag</td><td>Some trace flag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Set to <code>1</code> to enable this flag; set to <code>0</code> to disable this flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8c9b893c7621b4db5597cb4842bb166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN dnm_cli_setTraceByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *&#160;</td>
          <td class="paramname"><em>trInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse command string to set/clear some trace flag. </p>
<p>This function parses a string with the following format:</p>
<p><code>trace [module] [on|off]</code></p>
<p>Where <code>[module]</code> is a string identifying a trace module (as set by <a class="el" href="structdnm__cli__trinfo__t.html#a8f8f80d37794cde9472343e4487ba3eb" title="Name of module.">dnm_cli_trinfo_t::name</a>).</p>
<p>After identifying the module by its name, it will set or clear that module's traceflag if the command ends with <code>on</code> or <code>off</code>, respectively.</p>
<dl class="section post"><dt>Postcondition</dt><dd>After this function returns successfully, the address written at the location pointed to by <code>buf</code> will have advanced.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trInfo</td><td>Trace descriptor array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>String received over CLI, starting at <code>[module]</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> if the function completes successfully. </dd>
<dd>
<code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f57c81711d0dac0f14edfd1dbabaf6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_printTraceStateByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *&#160;</td>
          <td class="paramname"><em>trInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the state of all trace flags. </p>
<p>This function iterates through all trace descriptors in the array passed in the <code>trInfo</code> parameter, prints the name of each trace, and whether it is enabled or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trInfo</td><td>Trace descriptor array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ddb182397491f5d665bd8c28e2d1ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_helpTrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *&#160;</td>
          <td class="paramname"><em>trInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the list of all trace modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trInfo</td><td>Trace descriptor array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5e28c4434607fb47714aff262453a983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dnm_cli_showTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnm__cli__cont__t.html">dnm_cli_cont_t</a> *&#160;</td>
          <td class="paramname"><em>pCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnm__cli__trinfo__t.html">dnm_cli_trinfo_t</a> *&#160;</td>
          <td class="paramname"><em>trInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the list of enabled trace modules. </p>
<p>This function iterates through all trace descriptors in the array passed in the <code>trInfo</code> parameter and prints the name of the enabled traces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCont</td><td>CLI context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trInfo</td><td>Trace descriptor array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1ee97e9befcad6d2488ffd29ca39697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN dnm_cli_isNextToken </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT8U&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the next token in some with a given keyword. </p>
<p>This function finds the next token in the <code>buf</code> and compares that to the <code>keyWord</code>. Tokens in <code>buf</code> are separated by one or more spaces, or one or more <code>delimiter</code> characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer containing a string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyWord</td><td>Buffer containing the keyword to match. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>A delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> if the next token in the <code>buf</code> is <code>keyWord</code>. </dd>
<dd>
<code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34a558f2f3741279a6c0ccbef08354da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* dnm_cli_getNextToken </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT8U&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the next token in a string. </p>
<p>Tokens are separated by one or more spaces, or one or more <code>delimiter</code> characters.</p>
<p>This function iterates through the string at location <code>p</code>. It returns a pointer to the start of the next token in the string, and updates the location pointed at by <code>p</code> to the start of the token after the one found.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This function modifies the pointer value of <code>p</code> and the string itself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>Buffer containing a string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>A delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the start of the next token in <code>p</code>. </dd>
<dd>
<code>NULL</code> if no next token was found. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4ad1169f3848399aeeb810a0b6d5ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN dnm_cli_isEquIgnoreCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings, but ignore case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>First string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>Second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> if the strings are equivalent. </dd>
<dd>
<code>FALSE</code> if the strings are different. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a48d00aff005ad8c1e48e7a0b761f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* dnm_cli_uint64ToString </td>
          <td>(</td>
          <td class="paramtype">INT64U&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a INT64 number to a string. </p>
<dl class="section post"><dt>Postcondition</dt><dd>At most <code>size</code> bytes are written to the buffer pointed to by <code>buf</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>The buffer to write into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
